<!DOCTYPE html>
<html lang="en">
 
<head>
    <meta charset="UTF-8">
    <script
			  src="https://code.jquery.com/jquery-3.5.0.min.js"
			  integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ="
			  crossorigin="anonymous"></script>
    <style>
        canvas {
            background-color: white;
        }

    </style>
</head>
<body>
<!-- <div id="elo">
    <div style="display: inline-grid;">
        <label>Dodaj swój plik</label>
        <input type='file' accept='text/plain' onchange='openFile(event)'><br>
    <div id='output'>
    ...
    </div>
        <label>Lub rozpocznij z domyślnymi wartościami</label>
        <button onclick="startW()">Rozpocznij</button>
    </div>
</div> -->
    <canvas id="canvas"></canvas>
    <script>

        var canvas = document.querySelector("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
 
        var g = canvas.getContext("2d");

        canvas.addEventListener("mousemove", function (event) {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseX = event.x;
            mouseY = event.y;
 
            var incrX = (mouseX - prevMouseX) * 0.01;
            var incrY = (mouseY - prevMouseY) * 0.01;
 
            rotateCuboid(incrX, incrY);
        });

        var nodes = [[-1, -1, -1], [-1, -1, 1], [-1, 1, -1], [-1, 1, 1],
        [1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]];

        var faces= [[0, 1, 3, 2], [1, 0, 4, 5],
                [0, 2, 6, 4], [3, 1, 5, 7],
                [5, 4, 6, 7], [2, 3, 7, 6]];

        var mouseX = 0, prevMouseX, mouseY = 0, prevMouseY;

        var BLACK = "000000";
        var faceColor = "#00BFFF";
        var lightVector =[0.5, -0.2, -2];
        var backgroundLight = 0.1;

        $( document ).ready(function() {
            draw();
        });

        function createCuboid(x, y, z, w, h, d){
            nodes = [[x, y, z ], [x, y, z+d], [x, y+h, z ], [x, y+h, z+d], [x+w, y, z ], [x+w, y, z+d], [x+w, y+h, z ], [x+w, y+h, z+d]];
        }
        function scale(factor0, factor1, factor2) {
            nodes.forEach(function (node) {
                node[0] *= factor0;
                node[1] *= factor1;
                node[2] *= factor2;
            });
        }
        function rotateCuboid(angleX, angleY) {
 
            var sinX = Math.sin(angleX);
            var cosX = Math.cos(angleX);

            var sinY = Math.sin(angleY);
            var cosY = Math.cos(angleY);

            nodes.forEach(function (node) {
                var x = node[0];
                var y = node[1];
                var z = node[2];

                node[0] = x * cosX - z * sinX;
                node[2] = z * cosX + x * sinX;

                z = node[2];

                node[1] = y * cosY - z * sinY;
                node[2] = z * cosY + y * sinY;
            });
            draw();
        }

        var subtractVectors = function(v1, v2){
            return [[v1[0] - v2[0]],
                    [v1[1] - v2[1]],
                    [v1[2] - v2[2]]];
        };

        var normaliseVector = function(v) {
            var d = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
            return [v[0]/d, v[1]/d, v[2]/d];
        };

        var normalOfPlane = function(face, nodes) {
            var n1 = nodes[face[0]];
            var n2 = nodes[face[1]];
            var n3 = nodes[face[2]];
            
            var v1 = subtractVectors(n1, n2);
            var v2 = subtractVectors(n1, n3);
            
            var v3 = [[v1[1]*v2[2] - v1[2]*v2[1]],
                    [v1[2]*v2[0] - v1[0]*v2[2]],
                    [v1[0]*v2[1] - v1[1]*v2[0]]];
                    
            return v3;
        };

        var dotProduct = function(v1, v2){
            // Assume everything has 3 dimensions
            return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
        };

        function lerpColor(a, b, amount) { 

            var ah = parseInt(a.replace(/#/g, ''), 16),
                ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,
                bh = parseInt(b.replace(/#/g, ''), 16),
                br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,
                rr = ar + amount * (br - ar),
                rg = ag + amount * (bg - ag),
                rb = ab + amount * (bb - ab);

            return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
        }

        lightVector = normaliseVector(lightVector);

        function draw(){
            g.save();
 
            g.clearRect(0, 0, canvas.width, canvas.height);
            g.translate(canvas.width / 2, canvas.height / 2);
            for (var f in faces) {
                face = faces[f];
                var fnorm = normalOfPlane(face, nodes);
                
                if (fnorm[2] < 0) {
                    var l = Math.max(0, dotProduct(lightVector, normaliseVector(fnorm)));
                    l = backgroundLight + (1 - backgroundLight) * l;
                    var c = lerpColor(BLACK, faceColor, l);
                    g.fillStyle = c;
                      
                    if (face.length === 3) {
                        
                        g.beginPath();
                        g.moveTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.lineTo(nodes[face[1]][0], nodes[face[1]][1]);
                        g.lineTo(nodes[face[2]][0], nodes[face[2]][1]);
                        g.lineTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.closePath();
                        g.fill();
                    } else {
                        g.beginPath();
                        g.moveTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.lineTo(nodes[face[1]][0], nodes[face[1]][1]);
                        g.lineTo(nodes[face[2]][0], nodes[face[2]][1]);
                        g.lineTo(nodes[face[3]][0], nodes[face[3]][1]);
                        g.lineTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.closePath();
                        g.fill();
                    }
                }
            }
            g.beginPath();
            g.strokeStyle = "black";
            for (var f in faces) {
                face = faces[f];
                var fnorm = normalOfPlane(face, nodes);
                
                if (fnorm[2] < 0) {
                    if (face.length === 3) {
                        
                        g.moveTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.lineTo(nodes[face[1]][0], nodes[face[1]][1]);
                        g.lineTo(nodes[face[2]][0], nodes[face[2]][1]);
                        g.lineTo(nodes[face[0]][0], nodes[face[0]][1]);
                    } else {
                        g.moveTo(nodes[face[0]][0], nodes[face[0]][1]);
                        g.lineTo(nodes[face[1]][0], nodes[face[1]][1]);
                        g.lineTo(nodes[face[2]][0], nodes[face[2]][1]);
                        g.lineTo(nodes[face[3]][0], nodes[face[3]][1]);
                        g.lineTo(nodes[face[0]][0], nodes[face[0]][1]);
                    }
                }
            }
            g.closePath();
            g.stroke();
            g.restore();
        }
        scale(80, 120, 160);
        rotateCuboid(Math.PI / 5, Math.PI / 9);
    </script>
</body> 
</html>